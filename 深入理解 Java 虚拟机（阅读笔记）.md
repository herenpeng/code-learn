# 深入理解 Java 虚拟机（阅读笔记）

>在本篇阅读笔记中，我会在每个小节使用一些文字对小节的内容重要性进行一些描述，从内容重要性由低到高可以分为：  
>了解 -> 熟悉 -> 掌握 -> 重点

## 概述

### Java 的优势（熟悉）

- Java 是一门结构严谨，面向对象的编程语言
- Java 摆脱了硬件平台的束缚，实现了“一次编写，到处运行”的理想
- Java 提供了一种相对安全的内存管理和访问机制，避免了绝大部分内存泄露和指针越界问题
- Java 虚拟机实现了热点代码检测和运行时编译及优化，使得 Java 应用能随着运行时间的增长而获得更高的性能
- Java 有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库帮助用户实现各种各样的功能


### Java 技术体系（熟悉）

从传统意义上来看，JCP(`Java Community Process，Java 社区，这是一个由业界多家技术巨头组成的社区组织，用于定义和发展 Java 的技术规范`) 官方所定义的 Java 技术体系包括了以下几个组成部分：

- Java 程序设计语言
- 各种硬件平台上的 Java 虚拟机实现
- Class 文件格式
- Java 类库 API
- 来自商业机构和开源社区的第三方 Java 类库


我们可以把 Java 程序设计语言、Java 虚拟机、Java 类库这三部分统称为 JDK(Java Development Kit)，JDK 是用于支持 Java 程序开发的最小环境。

Java 类库 API 中的 Java SE API 子集和 Java 虚拟机这两部分统称为 JRE(Java Runtime Environment)，JRE 是支持 Java 程序运行的标准环境。



### Java 发展史（了解）

**1991年4月**：James Gosling 博士领导的绿色计划（Green Project）开始启动，此计划最初的目标是开发一种能够在各种消费性电子产品（如机顶盒、冰箱、收音机等）上运行的程序架构。这个计划的产品就是 Java 语言的前身：Oak（得名于 James Gosling 办公室外的一棵橡树）。Oak 当时在消费品市场上并不算成功，但随着 1995 年互联网潮流的兴起，Oak 迅速找了最适合自己发展的市场定位，并蜕变成为了 Java 语言。

**1995年5月23日**：Oak 语言改名为 Java，并在 SunWorld 大会上正式发布了 Java 1.0 版本。Java 语言第一次提出了“`Write Once,Run Anywhere`”的口号。

**1996年1月23日**:JDK 1.0 发布，Java 语言有了第一个正式版本的运行环境，JDK 1.0 提供了一个纯解释执行的 Java 虚拟机实现（Sun Classic VM）。JDK 1.0 版本的代表技术包括：Java 虚拟机、Applet、AWT 等。


**1996年4月**：十个最主要的操作系统和计算机供应商申明将在其产品中嵌入 Java 技术。5 月底，Sun 公司于美国旧金山举行了首届 JavaOne 大会，从此 JavaOne 成为了全世界数百万 Java 语言开发者每年一度的技术盛会。

**1997年2月19日**：Sun 公司发布了 JDK 1.1，Java 里许多最基础的技术支撑点（如 JDBC 等）都是在 JDK 1.1 版本中提出的，JDK 1.1 版本的技术代表有：JAR 文件格式、JDBC、JavaBeans、RMI 等。Java 语言的语法也有了一定的增强，如内部类（Inner Class）和反射（Reflection）都是在这时候出现的。  
一直到**1999年4月8日**，JDK 一共发布了 1.1.0 至 1.1.8 这 9 个版本。从 1.1.4 以后，每个 JDK 版本都有一个属于自己的名字（工程代号），分别为：JDK 1.1.4-Sparkler（宝石）、JDK 1.1.5-Pumpkin（南瓜）、JDK 1.1.6-Abigail（阿比盖尔，女子名）、JDK 1.1.7-Brutus（布鲁图，古罗马政治家和将军）和 JDK 1.1.8-Chelsea（切尔西，城市名）。


**1998年12月4号**：JDK 迎来了一个里程碑式的重要版本：工程代号为 Play ground （竞技场）的 JDK 1.2，Sun 在这个版本把 Java 技术体系拆分为三个方向，分别是面向桌面应用开发的 J2SE、面向企业级开发的 J2EE 和面向手机等移动终端开发的 J2ME。

JDK 1.2 版本的更新：

- 代表性技术有 EJB、Java Plug-in、Java IDL、Swing等
- 第一次在 Java 虚拟机中内置了 JIT(Just In Time) 即时编译器
- 内置了三个虚拟机：Classic VM、HotSpot VM 和 Exact VM
- Java API 层面，添加了 `strictfp` 关键字，类库中添加了 Collection 集合类


**1999年4月27日**：`HotSpot` 虚拟机诞生。HotSpot 最初由一家名为“Longview Techno-logies”的小公司开发，由于 HotSpot 的优异表现，这家公司在 1997 年被 Sun 公司收购。HotSpot 虚拟机刚发布时是作为 JDK 1.2 的附加程序提供的，后来它成为了 JDK 1.3 及之后所有 JDK 版本的默认 Java 虚拟机。


**2000年5月8日**：工程代号为 Kestrel（美洲红隼）的 JDK 1.3 版本发布。相对于 JDK 1.2，JDK 1.3 的改进主要体现在 Java 类库上。

JDK 1.3 版本的更新：

- 数学运算和新的 Timer API
- JNDI 服务从 JDK 1.3 开始被作为一项平台级服务提供


自从JDK 1.3开始，Sun公司维持着稳定的研发节奏：大约每隔两年发布一个JDK的主版本，以动物命名，期间发布的各个修正版本则以昆虫作为工程代号。


**2002年2月13日**：JDK 1.4 发布，工程代号为 Merlin（灰背隼）。JDK 1.4 是标志着 Java 真正走向成熟的一个版本，Compaq、Fujitsu、SAS、Symbian、IBM 等著名公司都有参与功能规划，甚至实现了自己独立发行的 JDK 1.4。

JDK 1.4 版本的更新：

- 正则表达式、异常链、NIO、日志类、XML 解析器和 XSLT 转换器等等


**2004年9月30日**：JDK 5 发布，工程代号 Tiger（老虎）。Sun 公司从这个版本开始放弃了谦逊的 “JDK 1.x” 的命名方式，将产品版本号修改成了 “JDK x”。从 JDK 1.2 以来，Java 在语法层面上的变动一直很小，而 JDK 5 在 Java 语法易用性上做出了非常大的改进。

JDK 5 版本的更新：

- 自动拆装箱、泛型、动态注解、枚举、可变长参数、遍历循环（foreach循环）
- 改进了 Java 的内存模型、提供了 `java.util.concurrent` 并发包

JDK 5 的官方申明可以支持 Windows 9x 操作系统的最后一个 JDK 版本。

**2006年12月11日**：JDK 6 发布，工程代号为 Mustang（野马）。在这个版本中，Sun 公司终结了从 JDK 1.2 开始已经有八年历史的J2EE、J2SE、J2ME的产品线命名方式，启用 JavaEE 6、Java SE6、JavaME6 的新命名来替代。


JDK 6 版本的更新：

- 提供初步的动态语言支持
- 提供编译器注解处理器和微型的 HTTP 服务器 API
- 改进 Java 虚拟机内部，包括锁与同步、垃圾收集、类加载等方面


**2006年11月13日**：JavaOne 大会上，Sun 公司宣布计划要把 Java 开源，在随后的一年多时间内，它陆续地将 JDK 的各个部分在 GPLv2（GNU General Public License v2） 协议下公开了源码，并建立了 OpenJDK 组织对这些源码进行独立管理。除了极少量的产权代码（Encumbered Code，这部分代码所有权不属于 Sun 公司，Sun 本身也无权进行开源处理）外，OpenJDK 几乎拥有了当时 SunJDK 7 的全部代码，OpenJDK 的质量主管曾经表示在 JDK 7 中，SunJDK 和 OpenJDK 除了代码文件头的版权注释之外，代码几乎是完全一样的，所以 OpenJDK 7与 SunJDK 7 本质上就是同一套代码库出来的产品。

JDK 6 发布以后，由于代码复杂性的增加、Java 开源、开发 JavaFX、世界经济危机 Oracle 对 Sun 的收购案等原因，Sun 公司在发展 Java 以外的事情上耗费了太多精力和资源，JDK 的更新没有能够继续维持两年发布一个主版本的研发速度，这导致了 JDK 6 的生命周期异常的长，一共发布了 211 个更新升级补丁，最后的版本为 Java SE 6 Update 211，于2018年10月18日发布。


**2009年2月19日**：工程代号为 Dolphin（海豚）的 JDK 7 完成了其第一个里程碑版本。按照 JDK 7 最初的功能规划，一共会设置十个里程碑。最后一个里程碑版本原计划定于2010年9月9日结束，但由于各种原因，JDK 7 最终无法按计划完成。

JDK 7最原始的功能清单，包含了许多重要的改进，其中规划的子项目包括：

- Lambda 项目：支持 Lambda 表达式，支持函数式编程（JDK 8 完成）
- Jigsaw 项目：虚拟机层面的模块化支持（JDK 9 完成）
- 动态语言支持：Java 是静态语言，为其他运行在 Java 虚拟机上的动态语言提供了支持（JDK 7 完成，JDK 11 改进）
- Garbage-First 收集器（JDK 7 完成）
- Coin 项目：Java 语法细节进化（JDK 8 完成）


**2009年4月20日**：Oracle 公司以每股 9.5 美元的价格收购 Sun。该交易价值约为74亿美元。同时，Oracle 公司获得了 Java 商标的版权。

**2011年7月28日**: Oracle 公司正式发布了 JDK 7 版本。

JDK 7 版本的更新：

- 提供新的 G1 收集器（G1在发布时依然处于 Experimental 状态，直至2012年4月的 Update 4 中才正式商用）
- 加强对非 Java 语言的调用支持（JSR-292，这项特性在 JDK 11 还有改动）
- 可并行的类加载架构


JDK 7 计划维护至 2022 年，迄今（面向付费用户）已发布了超过两百个更新补丁，最新版本为 JDK 7 Update 221。


**2014年3月18日**：JDK 8 正式发布。

JDK 8 版本的更新：

- Lambda 表达式的支持，这让 Java 语言拥有了流畅的函数式表达能力
- 内置 Nashorn JavaScript 引擎的支持
- 新的时间、日期 API
- 彻底移除了 HotSpot 的永久代


**2019年9月21日**：JDK 9 正式发布。

JDK 9 版本的更新：

- Jigsaw 项目，虚拟机层面的模块化支持
- JS Shell、JLink、JHSDB
- 整顿了 HotSpot 各个模块各自为战的日志系统
- 支持 HTTP2 客户端单 API


**2018年3月27日**：JDK 10 正式发布。

JDK 10 版本的更新：

- 统一源仓库、统一垃圾收集器接口、统一即时编译器接口
- 本地类型推断



**2018年9月25日**：JDK 11 正式发布。

- ZGC 垃圾收集器



**2019年3月20日**：JDK 12 正式发布。

JDK 12 版本的更新：

- Switch 表达式、Java 微测试套件（JMH）
- OpenJDK 中加入了由 RedHat 领导开发的 Shen-andoah 垃圾收集器（历史上唯一进入 OpenJDK，但是在 OracleJDK 中无法使用的功能）



### Java 虚拟机家族（了解）


#### Sun Classic VM

Sun Classic/Exact VM 是世界上第一款商用 Java 虚拟机，在1996年1月23日，Sun 发布 JDK 1.0，Java语言首次拥有了商用的正式运行环境，这个 JDK 中所带的虚拟机就是 Classic VM。

这款虚拟机只能使用纯解释器方式来执行 Java 代码，如果要使用即时编译器就必须进行外挂，但是加入外挂了即时编译器，即时编译器就会完全接管虚拟机的执行系统，解释器便不能再工作了。

Classic VM 基于句柄来查找对象。

JDK 1.0 引入，JDK 1.4 完全退出。


#### Sun Exact VM

JDK 1.2 时，在 Solaris 平台发布过一款名为 Exact VM 虚拟机，具有 热点探测、两级即时编译器器、编译器与解释器混合工作模式等。

因为 Exact VM 可以准确地知道内存中某个位置的数据具体是什么类型，Exact VM 摒弃了 Classic VM 基于句柄的对象访问方式，这样每次定位对象都少了一次间接查找的开销，显著提升执行性能。


#### HotSpot VM

HotSpot VM 是在 JDK 1.2 时引进的，在 JDK 1.3 时被切换为默认虚拟机，从此以后它就成为了 Sun/Oracle JDK 和 OpenJDK 中的默认 Java 虚拟机，也是目前使用范围最广的 Java 虚拟机。


HotSpot VM 的特点：

- 准确式内存管理
- 热点代码探测技术


#### Mobile/Embedded VM

Java ME 中的 Java 虚拟机。


#### BEA JRockit/IBM J9 VM


BEA System 公司的 JRockit 虚拟机，专注于服务端应用，目前已经不再发展。

IBM 公司的 J9 虚拟机，目前已捐献给 Eclipse 基金会，并重新命名为 Eclipse OMR 和 OpenJ9。J9 虚拟机的的职责分离与模块化做得比 HotSpot 更优秀。


#### BEA Liquid VM/Azul VM

Liquid VM 也被称为 JRockit VM(Virtual  Edition VM)，它是 BEA 公司开发的可以直接运行在自己 Hypervisor 系统上的 JRockit 虚拟机的虚拟化版本，Liquid VM 不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。由虚拟机越过通用操作系统直接控制硬件可以获得很多好处，如在线程调度时，不需要再进行内核态/用户态的切换，这样可以最大限度地发挥硬件的能力，提升 Java 程序的执行性能。


Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于 Azul Systems 公司的专有硬件 Vega 系统上的 Java 虚拟机。


#### Apache Harmony/Android Dalvik VM


Apache Harmony 是一个 Apache 软件基金会旗下以 Apache License 协议开源的实际兼容于 JDK 5 和 JDK 6 的 Java 程序运行平台，它含有自己的虚拟机和 Java 类库 API，用户可以在上面运行 Eclipse、Tomcat、Maven 等常用的 Java 程序。但是，它并没有通过 TCK 认证，所以我们不得不用一长串冗长拗口的语言来介绍它，而不能用一句 “Apache的JDK” 或者 “Apache 的 Java 虚拟机” 来直接代指。

Dalvik 虚拟机曾经是 Android 平台的核心组成部分之一，它的名字来源于冰岛一个名为 Dalvik 的小渔村。Dalvik 虚拟机并不是一个 Java 虚拟机，它没有遵循《Java 虚拟机规范》，不能直接执行 Java 的 Class 文件，使用寄存器架构而不是 Java 虚拟机中常见的栈架构。但是它与 Java 却又有着千丝万缕的联系，它执行的 DEX（Dalvik Executable） 文件可以通过 Class 文件转化而来，使用 Java 语法编写应用程
序，可以直接使用绝大部分的 Java API 等。


#### 其他

其他公司也号称有自己的专属 JDK 和虚拟机，但是它们要么是通过 Sun/Oracle 公司购买版权的方式获得的（如 HP、SAP 等），要么是基于 OpenJDK 项目改进而来的（如阿里巴巴、Twitter[推特] 等），都并非自己独立开发。

- JavaInJava 是 Sun 公司在 1997年- 1998年 间所研发的一个实验室性质的虚拟机，使用 Java 语言自举开发。执行速度不理想，但是具备研究价值。


## 运行时数据区域（重点）

Java 虚拟机在执行 Java 程序的过程中，会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，已经创建和销毁的时间。

Java 虚拟机所管理的内存将会包括一下几个运行时数据区域：

- 程序计数器
- Java 虚拟机栈
- 本地方法栈
- Java 堆
- 方法区


### 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。在 Java 虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器、分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于 Java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来执行的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为 “线程私有” 的内存。

如果线程执行的是 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 Natice 方法，这个计数器的值为空（Undefined）。

程序计数器是唯一一个在《Java 虚拟机规范》中没有规定任何 OutOfMemoryError 情况的区域。

### Java 虚拟机栈

Java 虚拟机栈（Java Virtual Machine Stack）是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表存放了编译器可知的各种 Java 虚拟机基本数据类型、对象引用类型、和 returnAddress 类型。

这些数据类型在局部变量表中存储空间以局部变量槽（Slot）来表示，其中 64 位长度的 long 和 double 类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间完全是确定的，在方法运行期间不会改变局部变量表的大小。（这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情）。


《Java 虚拟机规范》中，对 Java 虚拟机栈规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 OutOfMemoryError 异常，如果不能动态扩展，申请栈空间失败时，抛出 OutOfMemoryError 异常。


### 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。《Java 虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的 Java 虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError 异常。


### Java 堆

Java 堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。


Java 堆是垃圾收集器管理的内存区域，在一些资料中也被叫做“GC堆”。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以 Java 堆中经常会出现“新生代”"老年代""Eden空间"等名词。但其实这些区域的划分仅仅是一部分垃圾收集器的共同特性或者说是设计风格而已，而非 Java 虚拟机具体实现的固有内存布局，更不是《Java 虚拟机规范》里对 Java 堆的进一步细致划分。


根据《Java 虚拟机规范》的规定，Java 堆可以处于物理上的不连续的内存空间中，但在逻辑上，他应该被视为连续的。但对于大对象（如数组对象）多数虚拟机实现处于实现简单、存储高效的考虑，很可能会要求连续的内存空间。


Java 堆既可以被实现成固定大小的，也可以是可扩展的，目前主流的 Java 虚拟机都是按照可扩展来实现的（可以通过 -Xmx 和 -Xms 设定）。

如果在 Java 堆中无法申请到内存，并且堆无法再扩展的时候，Java 虚拟机将抛出 OutOfMemoryError 异常。



### 方法区

方法去（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于村粗已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

在 JDK 8 以前，HotSpot 虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot 的垃圾收集器能够像管理 Java 堆一样管理这部分内存，省去了专门为方法区编写内存管理代码的工作。但是对于其他 Java 虚拟机而已，是没有永久代的概念的。

方法区属于《Java 虚拟机规范》规定的一部分，而永久代是 HotSpot 设计团队对方法区的实现。

在 JDK 7 的 HotSpot，原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Metaspace）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。

《Java 虚拟机规范》对方法区的约束是非常宽松的，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展之外，甚至还可以选择不实现辣鸡收集。相对而言，垃圾收集行为在这个区域的确比较少出现，但是这个区域的对象并不算真的“永久”存在，方法区的内存回收目标主要是针对常量池的回收和对类型的卸载。

如果方法区无法满足新的内存分配需求，将抛出 OutOfMemoryError 异常。


#### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件除了有类的版本、字段、方法、接口等描述信息之外，还有一项常量池表（Constant Pool Table），用于存放编译期生产的各种字面量与符号引用，这部分内容将在类加载之后放到方法区的运行时常量池中。

当常量池无法再申请到内存时，会抛出 OutOfMemoryError 异常。


### 直接内存

直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现，所以我们放到这里一起讲解。

在 JDK 1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP 分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置 -Xmx 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。


## HotSpot 虚拟机对象（掌握）

### 对象的创建

创建对象的方法：

- new 关键字
- 克隆
- 反序列化
- 反射 newInstance() 方法

### 对象创建的过程

- 类加载检查
- 分配内存
- 初始化零值
- 设置对象头
- 执行 init 方法

**类加载检查**

当 Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行响应的类加载过程。

**分配内存**

对象所需要的内存大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便相当于把一块确定大小的内存从 Java 堆中划分出来。

假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式被称为“指针碰撞”（Bump The Pointer）。

但如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。

当使用带有压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用基于清除算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。

虚拟机创建对象的线程安全问题的解决方法：

- 对分配内存空间的动作进行同步处理，实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性
- 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。


**初始化零值**

虚拟机必须将分配到内存空间（但不包括对象头）都初始化零值，这步操作保证了对象的实例字段在 Java 代码中可以不赋初始化值就可以直接使用，使程序能访问到这些字段的数据类型所对应的零值。


**设置对象头**

Java 虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗（实际上对象的哈希吗对延后到真正调用 Object.hashCode() 方法时才计算）、对象的 GC 分代年龄等信息。这些信息放在对象的对象头（Object Header）之中，根据虚拟机当前运行的状态不同，对象头会有不同的设置方式。


**执行 init 方法**

从虚拟机的角度来看，一个对象已经产生了，但是从 Java 代码的视角来看，对象的创建才刚刚开始————构造函数，即 Class 文件中的 init 方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。

new 指令之后会接着执行 init 方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来了。



### 对象的内存布局（熟悉）

- 对象头
- 实例数据
- 对齐填充

**对象头**

HotSpot 虚拟机对象的对象头包括两类信息。

第一类是用于存储对象自身的运行时数据（如哈希吗、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，如果是一个数组对象，对象头中还必须要有一块用于记录数组长度的数据）。

另外一部分是类型指针，即对象指向它的类型元数据的指针，Java 虚拟机通过这个指针来确定改对象是哪个类的实例。


**实例数据**

程序代码里面所定义的各种类型的字段内容（包括父类继承，子类定义）。

**对齐填充**

这一部分不是必然存在的，只是起着占位符的作用。这是因为 HotSpot 虚拟机的自动内存管理要求对象起始地址必须是 8 字节的整数倍，即任何对象的大小都必须是 8 字节的整数倍。如果对象实例数据部分没有达到 8 字节的整数倍的话，就需要通过对齐填充来补全。


### 对象的访问定位

Java 程序的对象通过引用访问 Java 堆上的对象，《Java 虚拟机规范》并没有具体规定引用的具体实现，只规定了它是一个指向对象的引用，所以对象的访问方式是由虚拟机实现而定的。

主流的访问方式有两种：

- 句柄
- 直接指针

早期的 Sun Classic VM 就是使用句柄的访问方式，但是后面的其他虚拟机，因为具有准确地内存管理，能够知道内存中的哪些是基本数据类型，哪些是引用数据类型，所以都改用了基于直接指针的访问方式。

直接指针的访问方式比句柄的访问方式要少一步指针定位的时间开销，由于 Java 中对象的访问非常频繁，所以这类开销积少成多也成了一项极为可观的执行成本。



## 垃圾收集器与内存分配策略

> Java 与 C++ 之间有一堵由动态内存分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。



### 概述

垃圾收集技术需要完成的三件事：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？



程序计数器、虚拟机栈、本地方法栈这 3 个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行这出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来的时候就已知的，因此这几个区域的内存分配和回收都具备确定性。当方法结束或者线程结束时，内存自然就跟随着回收了。

Java 堆和方法区这两个区域则有着显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。



### 对象已死

#### 引用计数法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。



```java

public void static main(String[] args) {
    System.out.println("Hello,World");
}
```

















